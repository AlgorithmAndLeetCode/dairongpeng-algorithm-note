[TOC]
# 1 链表、栈、队列、递归、哈希

## 1.1 链表

### 1.1.1 单向链表
> 单向链表的节点结构：

```Go
// Node 单项链表节点结构
type Node struct {
	V int
	Next *Node
}
```
### 1.1.2 双向链表

> 双向链表的节点结构：

```Go
// DoubleNode 双向链表节点结构
type DoubleNode struct {
	V int
	Pre *DoubleNode
	Next *DoubleNode
}
```

### 1.1.3 单双链表简单练习

1. 单链表和双链表如何反转

> 例如单链表：1 -> 2 -> 3 转换为 3 -> 2 -> 1;


```Go
// ReverseLinkedList 翻转单链表
func ReverseLinkedList(head *Node) *Node {
	var pre *Node
	var next *Node
	for head != nil {
		// 把当前节点的下一个节点保存到next
		next = head.Next
		// 当前节点的指向，改为指向前一个节点
		head.Next = pre
		// pre 节点按原链表方向向下移动
		pre = head
		// head 节点按原链表方向向下移动
		head = next
	}
	// 按照原链表方向移动，当前节点为nil退出循环的时候，那么pre节点就是原链表的最后一个节点，链表被成功翻转。
	// 当前头结点pre返回
	return pre
}
```

```Go
// ReverseDoubleLinkedList 翻转双向链表
func ReverseDoubleLinkedList(head *DoubleNode) *DoubleNode {
	var pre *DoubleNode
	var next *DoubleNode
	for head != nil {
		// 保留当前节点的next节点的地址
		next = head.Next
		// 当前节点的下一个节点指pre
		head.Next = pre
		// 当前节点的上一个节点指向原链表当前节点的next节点。
		head.Pre = next
		// pre 节点按原链表方向向下移动
		pre = head
		// head 节点按原链表方向向下移动
		head = next
	}
	return pre
}
```

2. 把给定的值都删除

> 比如给定一个链表头结点，删除该节点上值为3的节点，那么可能头结点就是3，存在删头部的情况，这里最终返回应该是删除所有值为3的节点之后的新的头部

```Go
// RemoveValue 删除链表中值等于target的节点
func RemoveValue(head *Node, target int) *Node {
	// 处理链表头结点的值即等于target的节点
	for head != nil {
		if head.V != target {
			break
		}
		head = head.Next
	}

	// 1、链表中的节点值全部都等于target
	// 2、原始链表为nil
	if head == nil {
		return head
	}

	// head来到第一个不需要删除的位置
	pre := head
	cur := head
	for cur != nil {
		// 当前节点cur往下，有多少v等于target的节点，就删除多少节点
		if cur.V == target {
			pre.Next = cur.Next
		} else {
			pre = cur
		}
		// 当前节点向下滑动
		cur = cur.Next
	}
	return head
}
```

## 1.2 栈、队列
1. 逻辑概念

> 栈：数据先进后出，犹如弹夹

> 队列: 数据先进先出，排队

```Go
// 利用双向链表实现双端队列
package main

// DoubleEndsNode 双端队列节点
type DoubleEndsNode struct {
	val  int
	pre  *DoubleEndsNode
	next *DoubleEndsNode
}

// DoubleEndsList 双端队列接口
type DoubleEndsList interface {
	// AddFromHead 从头部添加节点
	AddFromHead(v int)
	// AddFromBottom 从尾部添加节点
	AddFromBottom(v int)
	// PopFromHead 从头部弹出节点
	PopFromHead() (int, bool)
	// PopFromBottom 从尾部弹出节点
	PopFromBottom() (int, bool)
	// IsEmpty 双端队列是否为空
	IsEmpty() bool
}

type DoubleEndsQueue struct {
	head *DoubleEndsNode
	tail *DoubleEndsNode
}

func (q *DoubleEndsQueue) AddFromHead(v int) {
	cur := &DoubleEndsNode{
		val: v,
	}
	if q.head == nil {
		q.head = cur
		q.tail = cur
	} else {
		cur.next = q.head
		q.head.pre = cur
		q.head = cur
	}
}

func (q *DoubleEndsQueue) AddFromBottom(v int) {
	cur := &DoubleEndsNode{
		val: v,
	}
	if q.head == nil {
		q.head = cur
		q.tail = cur
	} else {
		q.tail.next = cur
		cur.pre = q.tail
		q.tail = cur
	}
}

func (q *DoubleEndsQueue) PopFromHead() (int, bool) {
	if q.head == nil {
		return 0, false
	}
	v := q.head.val
	if q.head == q.tail {
		q.head = nil
		q.tail = nil
		return v, true
	} else {
		h := q.head
		q.head = q.head.next
		q.head.pre = nil
		h.next = nil
		return v, true
	}
}

func (q *DoubleEndsQueue) PopFromBottom() (int, bool) {
	if q.head == nil {
		return 0, false
	}
	v := q.tail.val
	if q.head == q.tail {
		q.head = nil
		q.tail = nil
		return v, true
	} else {
		t := q.tail
		q.tail = q.tail.pre
		q.tail.next = nil
		t.pre = nil
		return v, true
	}
}

func (q *DoubleEndsQueue) IsEmpty() bool {
	return q.head == nil
}
```

2. 栈、队列的底层实现方式

> 利用双向链表（双端队列）封装栈和队列

```Go
// Stack 利用双端队列实现栈
type Stack struct {
	qu *DoubleEndsQueue
}

func (s *Stack) push(v int) {
	s.qu.AddFromHead(v)
}

func (s *Stack)pop() (int, bool) {
	return s.qu.PopFromHead()
}

func (s *Stack)IsEmpty() bool {
	return s.qu.IsEmpty()
}
```

```Go
// Queue 利用双端队列实现队列
type Queue struct {
	qu *DoubleEndsQueue
}

func (q *Queue) push(v int) {
	q.qu.AddFromHead(v)
}

func (q *Queue) poll() (int, bool) {
	return q.qu.PopFromBottom()
}

func (q *Queue)IsEmpty() bool {
	return q.qu.IsEmpty()
}
```

> 数组实现栈和队列, 对于栈特别简单，略过，对于队列，如下


```Go
package main

import "fmt"

type Que struct {
	// 队列的底层结构
	arr []int
}

func (q *Que) push (v int) {
	q.arr = append(q.arr, v)
}

func (q *Que) poll () (int, bool){
	if len(q.arr) == 0 {
		return 0, false
	}
	v := q.arr[0]
	q.arr = q.arr[1:]
	return v, true
}

func main () {
	q := Que{}
	q.push(1)
	q.push(9)
	q.push(3)
	if poll, ok := q.poll(); ok {
		fmt.Println(poll)
	}
	if poll, ok := q.poll(); ok {
		fmt.Println(poll)
	}
	if poll, ok := q.poll(); ok {
		fmt.Println(poll)
	}
	if poll, ok := q.poll(); ok {
		fmt.Println(poll)
	}
}
```

## 1.3 栈、队列常见面试题

一、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能

1、pop、push、getMin操作的时间复杂度都是O(1)

2、设计的栈类型可以使用现成的栈结构

> 思路：准备两个栈，一个data栈，一个min栈。数据压data栈，min栈对比min栈顶元素，谁小加谁。这样的话data栈和min栈是同步上升的，元素个数一样多，且min栈的栈顶，是data栈所有元素中最小的那个。数据弹出data栈，我们同步弹出min栈，保证个数相等，且min栈弹出的就是最小值

```Java
package class02;

import java.util.Stack;

public class Code05_GetMinStack {

	public static class MyStack1 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack1() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
		        // 当前最小栈为空，直接压入
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			// 当前元素小于最小栈的栈顶，压入当前值
			} else if (newNum <= this.getmin()) {
				this.stackMin.push(newNum);
			}
			// 往数据栈中压入当前元素
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			int value = this.stackData.pop();
			if (value == this.getmin()) {
				this.stackMin.pop();
			}
			return value;
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			// 弹出操作，同步弹出，保证大小一致，只返回给用户data栈中的内容即可
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static void main(String[] args) {
		MyStack1 stack1 = new MyStack1();
		stack1.push(3);
		System.out.println(stack1.getmin());
		stack1.push(4);
		System.out.println(stack1.getmin());
		stack1.push(1);
		System.out.println(stack1.getmin());
		System.out.println(stack1.pop());
		System.out.println(stack1.getmin());

		System.out.println("=============");

		MyStack1 stack2 = new MyStack1();
		stack2.push(3);
		System.out.println(stack2.getmin());
		stack2.push(4);
		System.out.println(stack2.getmin());
		stack2.push(1);
		System.out.println(stack2.getmin());
		System.out.println(stack2.pop());
		System.out.println(stack2.getmin());
	}

}
```

二、如何用栈结构实现队列结构，如何用队列结构实现栈结构

> 这两种结构的应用实在太多，刷题时会大量见到

```Java
/**
* 两个栈实现队列
**/
package class02;

import java.util.Stack;

public class Code06_TwoStacksImplementQueue {

	public static class TwoStacksQueue {
		public Stack<Integer> stackPush;
		public Stack<Integer> stackPop;

		public TwoStacksQueue() {
			stackPush = new Stack<Integer>();
			stackPop = new Stack<Integer>();
		}

		// push栈向pop栈倒入数据
		private void pushToPop() {
			if (stackPop.empty()) {
				while (!stackPush.empty()) {
					stackPop.push(stackPush.pop());
				}
			}
		}

		public void add(int pushInt) {
			stackPush.push(pushInt);
			pushToPop();
		}

		public int poll() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.pop();
		}

		public int peek() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.peek();
		}
	}

	public static void main(String[] args) {
		TwoStacksQueue test = new TwoStacksQueue();
		test.add(1);
		test.add(2);
		test.add(3);
		System.out.println(test.peek());
		System.out.println(test.poll());
		System.out.println(test.peek());
		System.out.println(test.poll());
		System.out.println(test.peek());
		System.out.println(test.poll());
	}

}

```

```Java
/**
* 两个队列实现栈 
**/
package class02;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class Code07_TwoQueueImplementStack {

	public static class TwoQueueStack<T> {
		public Queue<T> queue;
		public Queue<T> help;

		public TwoQueueStack() {
			queue = new LinkedList<>();
			help = new LinkedList<>();
		}

		public void push(T value) {
			queue.offer(value);
		}

		public T poll() {
			while (queue.size() > 1) {
				help.offer(queue.poll());
			}
			T ans = queue.poll();
			Queue<T> tmp = queue;
			queue = help;
			help = tmp;
			return ans;
		}

		public T peek() {
			while (queue.size() > 1) {
				help.offer(queue.poll());
			}
			T ans = queue.poll();
			help.offer(ans);
			Queue<T> tmp = queue;
			queue = help;
			help = tmp;
			return ans;
		}

		public boolean isEmpty() {
			return queue.isEmpty();
		}

	}

	public static void main(String[] args) {
		System.out.println("test begin");
		TwoQueueStack<Integer> myStack = new TwoQueueStack<>();
		Stack<Integer> test = new Stack<>();
		int testTime = 1000000;
		int max = 1000000;
		for (int i = 0; i < testTime; i++) {
			if (myStack.isEmpty()) {
				if (!test.isEmpty()) {
					System.out.println("Oops");
				}
				int num = (int) (Math.random() * max);
				myStack.push(num);
				test.push(num);
			} else {
				if (Math.random() < 0.25) {
					int num = (int) (Math.random() * max);
					myStack.push(num);
					test.push(num);
				} else if (Math.random() < 0.5) {
					if (!myStack.peek().equals(test.peek())) {
						System.out.println("Oops");
					}
				} else if (Math.random() < 0.75) {
					if (!myStack.poll().equals(test.pop())) {
						System.out.println("Oops");
					}
				} else {
					if (myStack.isEmpty() != test.isEmpty()) {
						System.out.println("Oops");
					}
				}
			}
		}

		System.out.println("test finish!");

	}

}
```

## 1.4 递归

1、从思想上理解递归

2、从实现角度出发理解递归

例子：

求数组arr[L...R]中的最大值，怎么用递归方法实现

1、 将[L...R]范围分成左右两半。左[L...Mid],右[Mid+1...R]
2、 左部分求最大值，右部分求最大值
3、[L...R]范围上的最大值，就是max{左部分最大值,右部分最大值}

==2步骤是个递归过程，当范围上只有一个数，就可以不用再递归了==

```Java
package class02;

public class Code08_GetMax {

	// 求arr中的最大值
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	// arr[L..R]范围上求最大值  L ... R   N
	public static int process(int[] arr, int L, int R) {
		if (L == R) { // arr[L..R]范围上只有一个数，直接返回，base case
			return arr[L];
		}
		int mid = L + ((R - L) >> 1); // 中点
		// 左部分最大值
		int leftMax = process(arr, L, mid);
		// 右部分最大值
		int rightMax = process(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}

}
```

> 递归在系统中是怎么实现的？递归实际上利用的是系统栈来实现的。保存当前调用现场，去执行子问题，子问题的返回作为现场的需要的参数填充，最终构建还原栈顶的现场，返回。所以递归行为不是玄学，任何递归都可以改为非递归实现，我们自己压栈用迭代等实现就行

### 1.4.1 递归行为的时间复杂度

> 对于满足


```math
T(N) = aT(N/b) + O(N^d)
```
其中： a,b,d为常数

> 公式表示，子问题的规模是一致的,该子问题调用了a次，N/b代表子问题的规模，O(N^d)为除去递归调用剩余的时间复杂度。

> 比如上述问题的递归，[L...R]上有N个数，第一个子问题的规模是N/2，第二个子问题的规模也是N/2。子问题调用了2次。额为复杂度为O(1)，那么公式为：


```math
T(N) = 2T(N/2) + O(N^0)
```

结论：如果我们的递归满足这种公式，那么该递归的时间复杂度(Master公式)为

```math
logb^a > d   =>  O(N ^ (logb^a))

logb^a < d   =>  O(N^d)

logb^a == d   =>  O(N^d * logN)

```

那么上述问题的a=2, b=2,d=0,满足第一条，递归时间复杂度为：O(N)

## 1.5 哈希表HashMap、HashSet

> Hash表的增删改查，在使用的时候，一律认为时间复杂度是O(1)的

> 在Java中，int double float基础类型，按值传递; Integer, Double, Float按引用传递的，比较包装类型的值是否相等，使用equals方法。

==注意：在Java底层，包装类如果范围比较小，底层仍然采用值传递，比如Integer如果范围在-128~127之间，是按值传递的==

==但是在Hash表中，即使是包装类型的key，我们也一律按值传递，例如Hash<Integer,String>如果我们put相同的key的值，那么不会产生两个值相等的key而是覆盖操作。但是Hash表并不是一直是按值传递的，只是针对包装类型，如果是我们自定义的引用类型，那么仍然按引用传递==

## 1.6 顺序表 TreeMap、TreeSet

> 顺序表比哈希表功能多，但是顺序表的很多操作时间复杂度是O(logN)

> 有序表的底层可以有很多结构实现，比如AVL树，SB树，红黑树，跳表。其中AVL,SB，红黑都是具备各自平衡性的搜索二叉树

> 由于平衡二叉树每时每刻都会维持自身的平衡，所以操作为O(logN)。暂时理解，后面会单独整理

> 由于满足去重排序功能来维持底层树的平衡，所以如果是基础类型和包装类型的key直接按值来做比较，但是如果我们的key是自己定义的类型，那么我们要自己制定比较规则（比较器），用来让底层的树保持比较后的平衡

```Java
package class02;

import java.util.HashMap;
import java.util.HashSet;
import java.util.TreeMap;

public class HashMapAndSortedMap {
	
	
	public static class Node{
		public int value;
		public Node(int v) {
			 value = v;
		}
	}
	
	public static void main(String[] args) {
		// UnSortedMap
		HashMap<Integer, String> map = new HashMap<>();
		map.put(1000000, "我是1000000");
		map.put(2, "我是2");
		map.put(3, "我是3");
		map.put(4, "我是4");
		map.put(5, "我是5");
		map.put(6, "我是6");
		map.put(1000000, "我是1000001");
		
		System.out.println(map.containsKey(1));
		System.out.println(map.containsKey(10));
		
		System.out.println(map.get(4));
		System.out.println(map.get(10));
		
		map.put(4, "他是4");
		System.out.println(map.get(4));
		
		map.remove(4);
		System.out.println(map.get(4));
		
		
		
		//       key
		HashSet<String>  set = new HashSet<>();
		set.add("abc");
		set.contains("abc");
		set.remove("abc");
		
		// 哈希表，增、删、改、查，在使用时，O（1）
		
		System.out.println("=====================");
		
		int a = 100000;
		int b = 100000;
		System.out.println(a == b);
		
		Integer c = 100000;
		Integer d = 100000;
		System.out.println(c.equals(d));
		
		Integer e = 127;  //  - 128  ~  127
		Integer f = 127;
		System.out.println(e == f);
		
		
		
		HashMap<Node, String> map2 = new HashMap<>();
		Node node1 = new Node(1);
		Node node2 = node1;
		map2.put(node1, "我是node1");
		map2.put(node2, "我是node1");
		System.out.println(map2.size());
		
		System.out.println("======================");
		
		TreeMap<Integer, String> treeMap = new TreeMap<>();
		
		treeMap.put(3, "我是3");
		treeMap.put(4, "我是4");
		treeMap.put(8, "我是8");
		treeMap.put(5, "我是5");
		treeMap.put(7, "我是7");
		treeMap.put(1, "我是1");
		treeMap.put(2, "我是2");

		System.out.println(treeMap.containsKey(1));
		System.out.println(treeMap.containsKey(10));
		
		System.out.println(treeMap.get(4));
		System.out.println(treeMap.get(10));
		
		treeMap.put(4, "他是4");
		System.out.println(treeMap.get(4));
		
		treeMap.remove(4);
		System.out.println(treeMap.get(4));
		
		System.out.println(treeMap.firstKey());
		System.out.println(treeMap.lastKey());
		// <= 4
		System.out.println(treeMap.floorKey(4));
		// >= 4
		System.out.println(treeMap.ceilingKey(4));
		// O(logN)	
    
	}
}
```




