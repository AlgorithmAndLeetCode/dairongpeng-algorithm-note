[TOC]
# 1 二叉树基本算法（续）

## 1.1 直观打印一颗二叉树

> 如何设计一个打印整颗数的打印函数,简单起见，我们躺着打印，正常的树我们顺时针旋转90°即可

```Java
package class07;

public class Code05_PrintBinaryTree {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		// 打印函数，先传入头结点
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

    // head表示当前传入节点
    // height当前节点所在的高度
    // to表示当前节点的指向信息
    // len表示打印当前值填充到多少位当成一个完整的值
	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		// 递归右树，右树向下指
		printInOrder(head.right, height + 1, "v", len);
		/**
		* 打印自己的值
		* val 表示值内容
		**/
		String val = to + head.value + to;
		int lenM = val.length();
		// 按照len算该值左侧需要填充多少空格
		int lenL = (len - lenM) / 2;
		// 按照len算该值右侧需要填充多少空格
		int lenR = len - lenM - lenL;
		// 实际值加上左右占位，表示每个值包括占位之后大小
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		// 递归左树，左树向上指
		printInOrder(head.left, height + 1, "^", len);
	}

  // 根据height*len补空格
	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}

	public static void main(String[] args) {
		Node head = new Node(1);
		head.left = new Node(-222222222);
		head.right = new Node(3);
		head.left.left = new Node(Integer.MIN_VALUE);
		head.right.left = new Node(55555555);
		head.right.right = new Node(66);
		head.left.left.right = new Node(777);
		printTree(head);

		head = new Node(1);
		head.left = new Node(2);
		head.right = new Node(3);
		head.left.left = new Node(4);
		head.right.left = new Node(5);
		head.right.right = new Node(6);
		head.left.left.right = new Node(7);
		printTree(head);

		head = new Node(1);
		head.left = new Node(1);
		head.right = new Node(1);
		head.left.left = new Node(1);
		head.right.left = new Node(1);
		head.right.right = new Node(1);
		head.left.left.right = new Node(1);
		printTree(head);

	}

}

```

## 1.2 题目实战

### 1.2.1 题目一：返回二叉树的后继节点

题目描述：二叉树的结构定义如下：

```Java
Class Node {
    V value;
    Node left;
    Node right;
    // 指向父亲节点
    Node parent;
}
```

给你二叉树中的某个节点，返回该节点的后继节点。后继节点表示一颗二叉树中，在中序遍历的序列中，一个个节点的下一个节点是谁。

> 方法一，通常解法思路：由于我们的节点有指向父节点的指针，而整颗二叉树的头结点的父节点为null。那么我们可以找到整棵树的头结点，然后中序遍历，再找到给定节点的下一个节点，就是该节点的后续节点。


> 方法二，考虑一个节点和其后继节点的结构之间的关系：

> 如果一个节点x有右树，那么其后继节点就是右树最左的节点。

> 如果x没有右树，往上找父亲节点。如果x是其父亲的右孩子继续往上找，如果某节点是其父亲节点的左孩子，那么该节点的父亲就是x的后继节点

> 即如果某节点左树的最右节点是x，那么该节点是x的后继

> 如果找父节点，一直找到null都不满足，那么该节点是整棵树的最右节点，没有后继

```Java
package class07;

public class Code07_SuccessorNode {

	public static class Node {
		public int value;
		public Node left;
		public Node right;
		public Node parent;

		public Node(int data) {
			this.value = data;
		}
	}

    // 给定节点，返回后继
	public static Node getSuccessorNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		// 无右子树
		} else { 
			Node parent = node.parent;
			// 当前节点是其父亲节点右孩子，继续
			while (parent != null && parent.right == node) { 
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

  // 找右树上的最左节点
	public static Node getLeftMost(Node node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}

	public static void main(String[] args) {
		Node head = new Node(6);
		head.parent = null;
		head.left = new Node(3);
		head.left.parent = head;
		head.left.left = new Node(1);
		head.left.left.parent = head.left;
		head.left.left.right = new Node(2);
		head.left.left.right.parent = head.left.left;
		head.left.right = new Node(4);
		head.left.right.parent = head.left;
		head.left.right.right = new Node(5);
		head.left.right.right.parent = head.left.right;
		head.right = new Node(9);
		head.right.parent = head;
		head.right.left = new Node(8);
		head.right.left.parent = head.right;
		head.right.left.left = new Node(7);
		head.right.left.left.parent = head.right.left;
		head.right.right = new Node(10);
		head.right.right.parent = head.right;

		Node test = head.left.left;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.left.left.right;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.left;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.left.right;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.left.right.right;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.right.left.left;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.right.left;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.right;
		System.out.println(test.value + " next: " + getSuccessorNode(test).value);
		test = head.right.right; // 10's next is null
		System.out.println(test.value + " next: " + getSuccessorNode(test));
	}

}
```

> 后继节点对应的是前驱结点，前驱结点的含义是中序遍历，某节点的前一个节点

### 1.2.2 题目二：折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。

此时折痕是凹下去的，即折痕凸起的方向指向纸条的背面。

如果从纸条的下边向上方对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕，下折痕和上折痕。

给定一个输入参数N,代表纸条都从下边向上方连续对折N次。请从上到下打印所有的折痕的方向。

例如：N=1时，打印: down 。N=2时，打印：down down up

> 规律，大于一次后，每次折痕出现的位置都是在上次折痕的上方出现凹折痕，下方出现凸折痕。所以我们没必要构建这颗树，就可以用递归思维解决

```text
对应的树结构按层输出为：
            1凹
    2凹             2凸
3凹     3凸     3凹     3凸
```

```Java
package class07;

public class Code08_PaperFolding {

	public static void printAllFolds(int N) {
	  // 先从头结点出发，i初始值为1，切第一次的头结点折痕为凹折痕
		printProcess(1, N, true);
	}

	// 递归过程，来到了某一个节点，
	// i是节点的层数，N一共的层数，down == true  凹    down == false 凸
	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		// 每个当前节点的左子节点是凹
		printProcess(i + 1, N, true);
		System.out.println(down ? "凹 " : "凸 ");
		// 每个当前节点的右子树是凸
		printProcess(i + 1, N, false);
	}

	public static void main(String[] args) {
		int N = 3;
		// 折N次，打印所有凹凸分布情况
		printAllFolds(N);
	}
}
```

# 2 二叉树的递归套路

1、 可以解决面试中的绝大部分二叉树(95%以上)的问题，尤其是树形dp问题

2、 其本质是利用递归遍历二叉树的便利性，每个节点在递归的过程中可以回到该节点3次


==具体步骤为：==

1. 假设以X节点为头，假设可以向X左树和右树要任何信息
2. 在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（最重要），常见分类是与X无关的答案，与X有关的答案
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树信息和右树信息求全集，就是任何一颗子树都需要返回的信息S
5. 递归函数都返回S，每颗子树都这么要求
6. 写代码，在代码中考虑如何把左树信息和右树信息整合出整棵树的信息

## 2.1 二叉树的递归套路深度实践

### 2.1.1 例一：判断二叉树平衡与否

给定一棵二叉树的头结点head，返回这颗二叉树是不是平衡二叉树

> 平衡树概念：在一棵二叉树中，每一个子树，左树的高度和右树的高度差不超过1

> 那么如果以X为头的这颗树，要做到平衡，那么X的左树要是平衡的，右树也是平衡的，且X的左树高度和右树高度差不超过1

> 所以该题，我们X需要向左右子树要的信息为，1.高度 2. 是否平衡

```Java
package class08;

public class Code01_IsBalanced {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static boolean isBalanced1(Node head) {
		boolean[] ans = new boolean[1];
		ans[0] = true;
		process1(head, ans);
		return ans[0];
	}

	public static int process1(Node head, boolean[] ans) {
		if (!ans[0] || head == null) {
			return -1;
		}
		int leftHeight = process1(head.left, ans);
		int rightHeight = process1(head.right, ans);
		if (Math.abs(leftHeight - rightHeight) > 1) {
			ans[0] = false;
		}
		return Math.max(leftHeight, rightHeight) + 1;
	}

### ### 	public static boolean isBalanced2(Node head) {
		return process2(head).isBalaced;
	}

	// 左、右要求一样，Info 表示信息返回的结构体
	public static class Info {
	  // 是否平衡
		public boolean isBalaced;
		// 高度多少
		public int height;

		public Info(boolean b, int h) {
			isBalaced = b;
			height = h;
		}
	}

  // 递归调用，X自身也要返回信息Info。
  // 解决X节点(当前节点)怎么返回Info信息
	public static Info process2(Node X) {
	  // base case
		if (X == null) {
			return new Info(true, 0);
		}
		// 得到左树信息
		Info leftInfo = process2(X.left);
		// 得到右树信息
		Info rightInfo = process2(X.right);
		
		// 高度等于左右最大高度，加上当前头结点的高度1
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		boolean isBalanced = true;
		// 左树不平衡或者右树不平衡，或者左右两子树高度差超过1
		// 那么当前节点为头的树，不平衡
		if (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) > 1) {
			isBalanced = false;
		}
		// 加工出当前节点的信息返回
		return new Info(isBalanced, height);
	}

	// for test
	public static Node generateRandomBST(int maxLevel, int maxValue) {
		return generate(1, maxLevel, maxValue);
	}

	// for test
	public static Node generate(int level, int maxLevel, int maxValue) {
		if (level > maxLevel || Math.random() < 0.5) {
			return null;
		}
		Node head = new Node((int) (Math.random() * maxValue));
		head.left = generate(level + 1, maxLevel, maxValue);
		head.right = generate(level + 1, maxLevel, maxValue);
		return head;
	}

	public static void main(String[] args) {
		int maxLevel = 5;
		int maxValue = 100;
		int testTimes = 1000000;
		for (int i = 0; i < testTimes; i++) {
			Node head = generateRandomBST(maxLevel, maxValue);
			if (isBalanced1(head) != isBalanced2(head)) {
				System.out.println("Oops!");
			}
		}
		System.out.println("finish!");
	}

}

```

### 2.1.2 例二：返回二叉树任意两个节点最大值

给定一棵二叉树的头结点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离

> 1、有可能最大距离和当前节点X无关，即最大距离是X左树的最大距离，或者右树的最大距离

> 2、最大距离跟X有关，即最大距离通过X。左树离X最远的点，到X右树上离X最远的点。即X左树的高度加上X自身高度1，加上X右树上的高度

> 结论：那么根据递归套路，我们每次递归，需要返回X左树的最大距离和高度，同理返回X右树的最大距离和高度。Info包含最大距离和高度

```Java
package class08;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Code08_MaxDistance {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static int maxDistance1(Node head) {
		if (head == null) {
			return 0;
		}
		ArrayList<Node> arr = getPrelist(head);
		HashMap<Node, Node> parentMap = getParentMap(head);
		int max = 0;
		for (int i = 0; i < arr.size(); i++) {
			for (int j = i; j < arr.size(); j++) {
				max = Math.max(max, distance(parentMap, arr.get(i), arr.get(j)));
			}
		}
		return max;
	}

	public static ArrayList<Node> getPrelist(Node head) {
		ArrayList<Node> arr = new ArrayList<>();
		fillPrelist(head, arr);
		return arr;
	}

	public static void fillPrelist(Node head, ArrayList<Node> arr) {
		if (head == null) {
			return;
		}
		arr.add(head);
		fillPrelist(head.left, arr);
		fillPrelist(head.right, arr);
	}

	public static HashMap<Node, Node> getParentMap(Node head) {
		HashMap<Node, Node> map = new HashMap<>();
		map.put(head, null);
		fillParentMap(head, map);
		return map;
	}

	public static void fillParentMap(Node head, HashMap<Node, Node> parentMap) {
		if (head.left != null) {
			parentMap.put(head.left, head);
			fillParentMap(head.left, parentMap);
		}
		if (head.right != null) {
			parentMap.put(head.right, head);
			fillParentMap(head.right, parentMap);
		}
	}

	public static int distance(HashMap<Node, Node> parentMap, Node o1, Node o2) {
		HashSet<Node> o1Set = new HashSet<>();
		Node cur = o1;
		o1Set.add(cur);
		while (parentMap.get(cur) != null) {
			cur = parentMap.get(cur);
			o1Set.add(cur);
		}
		cur = o2;
		while (!o1Set.contains(cur)) {
			cur = parentMap.get(cur);
		}
		Node lowestAncestor = cur;
		cur = o1;
		int distance1 = 1;
		while (cur != lowestAncestor) {
			cur = parentMap.get(cur);
			distance1++;
		}
		cur = o2;
		int distance2 = 1;
		while (cur != lowestAncestor) {
			cur = parentMap.get(cur);
			distance2++;
		}
		return distance1 + distance2 - 1;
	}

	public static int maxDistance2(Node head) {
		return process(head).maxDistance;
	}

    // 我们的信息，整棵树的最大距离和整棵树的高度
	public static class Info {
		public int maxDistance;
		public int height;

		public Info(int dis, int h) {
			maxDistance = dis;
			height = h;
		}
	}
    
  // 以X节点为头
	public static Info process(Node X) {
	  // base case
		if (X == null) {
			return new Info(0, 0);
		}
		// 默认从左树拿到我们需要的info
		Info leftInfo = process(X.left);
		// 默认从右树拿到我们需要的info
		Info rightInfo = process(X.right);
		// 用左右树的信息，加工自身的info
		// 自身的高度是，左右较大的高度加上自身节点高度1
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		// 自身最大距离，是左右树最大距离和左右树高度相加再加1，求最大值
		int maxDistance = Math.max(
				Math.max(leftInfo.maxDistance, rightInfo.maxDistance),
				leftInfo.height + rightInfo.height + 1);
		// 自身的info返回
		return new Info(maxDistance, height);
	}

	// for test
	public static Node generateRandomBST(int maxLevel, int maxValue) {
		return generate(1, maxLevel, maxValue);
	}

	// for test
	public static Node generate(int level, int maxLevel, int maxValue) {
		if (level > maxLevel || Math.random() < 0.5) {
			return null;
		}
		Node head = new Node((int) (Math.random() * maxValue));
		head.left = generate(level + 1, maxLevel, maxValue);
		head.right = generate(level + 1, maxLevel, maxValue);
		return head;
	}

	public static void main(String[] args) {
		int maxLevel = 4;
		int maxValue = 100;
		int testTimes = 1000000;
		for (int i = 0; i < testTimes; i++) {
			Node head = generateRandomBST(maxLevel, maxValue);
			if (maxDistance1(head) != maxDistance2(head)) {
				System.out.println("Oops!");
			}
		}
		System.out.println("finish!");
	}

}
```

### 2.1.3 例三：返回二叉树中的最大二叉搜索树Size

给定个一颗二叉树的头结点head，返回这颗二叉树中最大的二叉搜索树的Size

> 搜索二叉树概念：整颗树上没有重复值，左树的值都比我小，右树的值都比我大。每颗子树都如此。

> 递归套路。1、与当前节点X无关，即最终找到的搜索二叉树，不以X为头

> 2、与X有关，那么X的左树整体是搜索二叉树，右树同理，且左树的最大值小于X,右树的最小值大于X

```Java
package class08;

import java.util.ArrayList;

public class Code04_MaxSubBSTSize {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static int getBSTSize(Node head) {
		if (head == null) {
			return 0;
		}
		ArrayList<Node> arr = new ArrayList<>();
		in(head, arr);
		for (int i = 1; i < arr.size(); i++) {
			if (arr.get(i).value <= arr.get(i - 1).value) {
				return 0;
			}
		}
		return arr.size();
	}

	public static void in(Node head, ArrayList<Node> arr) {
		if (head == null) {
			return;
		}
		in(head.left, arr);
		arr.add(head);
		in(head.right, arr);
	}

	public static int maxSubBSTSize1(Node head) {
		if (head == null) {
			return 0;
		}
		int h = getBSTSize(head);
		if (h != 0) {
			return h;
		}
		return Math.max(maxSubBSTSize1(head.left), maxSubBSTSize1(head.right));
	}

	public static int maxSubBSTSize2(Node head) {
		if (head == null) {
			return 0;
		}
		return process(head).maxSubBSTSize;
	}

//	public static Info process(Node head) {
//		if (head == null) {
//			return null;
//		}
//		Info leftInfo = process(head.left);
//		Info rightInfo = process(head.right);
//		int min = head.value;
//		int max = head.value;
//		int maxSubBSTSize = 0;
//		if (leftInfo != null) {
//			min = Math.min(min, leftInfo.min);
//			max = Math.max(max, leftInfo.max);
//			maxSubBSTSize = Math.max(maxSubBSTSize, leftInfo.maxSubBSTSize);
//		}
//		if (rightInfo != null) {
//			min = Math.min(min, rightInfo.min);
//			max = Math.max(max, rightInfo.max);
//			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
//		}
//		boolean isBST = false;
//		if ((leftInfo == null ? true : (leftInfo.isAllBST && leftInfo.max < head.value))
//				&& (rightInfo == null ? true : (rightInfo.isAllBST && rightInfo.min > head.value))) {
//			isBST = true;
//			maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
//					+ (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1;
//		}
//		return new Info(isBST, maxSubBSTSize, min, max);
//	}

	// 任何子树,都返回4个信息
	public static class Info {
	  // 整体是否是二叉搜索树
		public boolean isAllBST;
		// 最大的满足二叉搜索树树条件的size
		public int maxSubBSTSize;
		// 整棵树的最小值
		public int min;
		// 整棵树的最大值
		public int max;

		public Info(boolean is, int size, int mi, int ma) {
			isAllBST = is;
			maxSubBSTSize = size;
			min = mi;
			max = ma;
		}
	}

  // 以X为头
	public static Info process(Node X) {
	  // base case
		if(X == null) {
			return null;
		}
		// 默认左树可以给我info信息
		Info leftInfo = process(X.left);
		// 默认右树可以给我info信息
		Info rightInfo = process(X.right);

    // 通过左右树给我的信息，加工我自己的info

		int min = X.value;
		int max = X.value;
		
		// 左树不为空，加工min和max
		if(leftInfo != null) {
			min = Math.min(min, leftInfo.min);
			max = Math.max(max, leftInfo.max);
		}
		// 右树不为空，加工min和max
		if(rightInfo != null) {
			min = Math.min(min, rightInfo.min);
			max = Math.max(max, rightInfo.max);
		}

    // 可能性1与X无关的情况
		int maxSubBSTSize = 0;
		if(leftInfo != null) {
			maxSubBSTSize = leftInfo.maxSubBSTSize;
		}
		if(rightInfo !=null) {
			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
		}
		
		// 可能性2，与X有关
		boolean isAllBST = false;

		if(
				// 左树和人右树整体需要是搜索二叉树
				(  leftInfo == null ? true : leftInfo.isAllBST    )
				&&
				(  rightInfo == null ? true : rightInfo.isAllBST    )
				&&
				// 左树最大值<X，右树最小值>X
				(leftInfo == null ? true : leftInfo.max < X.value)
				&&
				(rightInfo == null ? true : rightInfo.min > X.value)
				
				
				) {
			
			maxSubBSTSize = 
					(leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
					+
					(rightInfo == null ? 0 : rightInfo.maxSubBSTSize)
					+
					1;
					isAllBST = true;
			
			
		}

		return new Info(isAllBST, maxSubBSTSize, min, max);
	}
	
	// for test
	public static Node generateRandomBST(int maxLevel, int maxValue) {
		return generate(1, maxLevel, maxValue);
	}

	// for test
	public static Node generate(int level, int maxLevel, int maxValue) {
		if (level > maxLevel || Math.random() < 0.5) {
			return null;
		}
		Node head = new Node((int) (Math.random() * maxValue));
		head.left = generate(level + 1, maxLevel, maxValue);
		head.right = generate(level + 1, maxLevel, maxValue);
		return head;
	}

	public static void main(String[] args) {
		int maxLevel = 4;
		int maxValue = 100;
		int testTimes = 1000000;
		for (int i = 0; i < testTimes; i++) {
			Node head = generateRandomBST(maxLevel, maxValue);
			if (maxSubBSTSize1(head) != maxSubBSTSize2(head)) {
				System.out.println("Oops!");
			}
		}
		System.out.println("finish!");
	}

}
```

### 2.1.4 例四：派对最大快乐值

排队最大快乐值问题，员工信息定义如下，多叉树结构：

```Java
class Employee{
    // 这名员工可以带来的快乐值
    public int happy;
    // 这名员工有哪些直接的下级
    List<Employee> subordinates;
}
```

每个员工都符合Employee类的描述，整个公司的人员结构可以看作是一颗标准的，没有环的多叉树。树的头结点是公司唯一的老板。除了老板外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates为空），除了基层员工股外，每个员工都有一个或多个直接下级。


现在公司要来办party，你可以决定哪些员工来，哪些员工不来，规则:

1、 如果某个员工来了，那么这个员工的所有直接下级都不能来

2、 排队的整体快乐值是所有到场员工的快乐值的累加

3、 你的目标是让排队的整体快乐值尽量的大

给定一颗多叉树头结点boss，请返回排队的最大快乐值

> 思路：根据X来与不来分类

> 如果X来，我们能获得X的快乐值X.happy。X的直接子不能来，但我们能拿到X某个子树整棵树的的最大快乐值

> 如果X不来，不发请柬，我们能获得X的快乐值为0，X直接子树头结点来或者不来求最大值...

```Java
package class08;

import java.util.ArrayList;
import java.util.List;

public class Code09_MaxHappy {

  // 员工对应的多叉树节点结构
	public static class Employee {
		public int happy;
		public List<Employee> nexts;

		public Employee(int h) {
			happy = h;
			nexts = new ArrayList<>();
		}

	}

	public static int maxHappy1(Employee boss) {
		if (boss == null) {
			return 0;
		}
		return process1(boss, false);
	}

	public static int process1(Employee cur, boolean up) {
		if (up) {
			int ans = 0;
			for (Employee next : cur.nexts) {
				ans += process1(next, false);
			}
			return ans;
		} else {
			int p1 = cur.happy;
			int p2 = 0;
			for (Employee next : cur.nexts) {
				p1 += process1(next, true);
				p2 += process1(next, false);
			}
			return Math.max(p1, p2);
		}
	}

	public static int maxHappy2(Employee boss) {
		if (boss == null) {
			return 0;
		}
		Info all = process2(boss);
		return Math.max(all.yes, all.no);
	}

  // 递归信息
	public static class Info {
	  // 头结点在来的情况下整棵树的最大值
		public int yes;
		// 头结点在不来的情况下整棵树的最大值
		public int no;

		public Info(int y, int n) {
			yes = y;
			no = n;
		}
	}

	public static Info process2(Employee x) {
	  // base case 基层员工
		if (x.nexts.isEmpty()) {
			return new Info(x.happy, 0);
		}
		// 当前X来的初始值
		int yes = x.happy;
		// 当前X不来的初始值
		int no = 0;
		// 每棵子树调用递归信息
		for (Employee next : x.nexts) {
			Info nextInfo = process2(next);
			// 根据子树的递归返回的信息，加工自身的info
			// 如果X来，子不来
			yes += nextInfo.no;
			// 如果X不来，子不确定来不来
			no += Math.max(nextInfo.yes, nextInfo.no);
		}
		return new Info(yes, no);
	}

	// for test
	public static Employee genarateBoss(int maxLevel, int maxNexts, int maxHappy) {
		if (Math.random() < 0.02) {
			return null;
		}
		Employee boss = new Employee((int) (Math.random() * (maxHappy + 1)));
		genarateNexts(boss, 1, maxLevel, maxNexts, maxHappy);
		return boss;
	}

	// for test
	public static void genarateNexts(Employee e, int level, int maxLevel, int maxNexts, int maxHappy) {
		if (level > maxLevel) {
			return;
		}
		int nextsSize = (int) (Math.random() * (maxNexts + 1));
		for (int i = 0; i < nextsSize; i++) {
			Employee next = new Employee((int) (Math.random() * (maxHappy + 1)));
			e.nexts.add(next);
			genarateNexts(next, level + 1, maxLevel, maxNexts, maxHappy);
		}
	}

	public static void main(String[] args) {
		int maxLevel = 4;
		int maxNexts = 7;
		int maxHappy = 100;
		int testTimes = 100000;
		for (int i = 0; i < testTimes; i++) {
			Employee boss = genarateBoss(maxLevel, maxNexts, maxHappy);
			if (maxHappy1(boss) != maxHappy2(boss)) {
				System.out.println("Oops!");
			}
		}
		System.out.println("finish!");
	}

}

```
